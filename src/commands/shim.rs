//! Shim generation and execution for Docker-First enforcement
//!
//! Creates shims in ./bin that intercept commands (pnpm, npm, node, etc.)
//! and route them to Docker containers based on manifest.toml configuration.

use std::env;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};

use anyhow::{Context, Result};
use colored::Colorize;
use glob::Pattern;

use crate::manifest::{Manifest, MANIFEST_FILE};

/// Install shims in ./bin directory
pub fn install() -> Result<()> {
    let manifest = Manifest::load(MANIFEST_FILE)
        .context("Failed to load manifest.toml. Run 'airis init' first.")?;

    let bin_dir = Path::new("bin");
    fs::create_dir_all(bin_dir).context("Failed to create bin directory")?;

    // Create _shim (the main router)
    let shim_path = bin_dir.join("_shim");
    create_shim_script(&shim_path, &manifest)?;

    println!("{}", "üîß Installing Docker-First shims...".bright_blue());
    println!();

    // Create symlinks for each command
    for cmd in &manifest.docker.shim_commands {
        let cmd_path = bin_dir.join(cmd);

        // Remove existing if present
        if cmd_path.exists() {
            fs::remove_file(&cmd_path)?;
        }

        // Create wrapper script that calls _shim
        create_command_wrapper(&cmd_path)?;

        println!("   {} bin/{}", "‚úì".green(), cmd);
    }

    println!();
    println!("{}", "‚úÖ Shims installed successfully!".green());
    println!();
    println!("{}", "Next steps:".bright_yellow());
    println!("  1. Add to PATH: export PATH=\"$(pwd)/bin:$PATH\"");
    println!("  2. Or add to .envrc: export PATH=\"$(pwd)/bin:$PATH\"");
    println!("  3. Run 'direnv allow' if using direnv");
    println!();
    println!("{}", "Now all commands (pnpm, npm, node, etc.) will run inside Docker!".cyan());

    Ok(())
}

/// Create the main _shim script
fn create_shim_script(path: &Path, manifest: &Manifest) -> Result<()> {
    let compose = &manifest.docker.compose;
    let default_service = &manifest.docker.service;
    let default_workdir = &manifest.docker.workdir;

    // Build routes as shell case statements
    let mut route_cases = String::new();
    for route in &manifest.docker.routes {
        route_cases.push_str(&format!(
            r#"
    {glob})
      SERVICE="{service}"
      WORKDIR="{workdir}"
      ;;"#,
            glob = route.glob,
            service = route.service,
            workdir = route.workdir.replace("{match}", "$MATCH"),
        ));
    }

    let script = format!(r##"#!/usr/bin/env bash
# Auto-generated by airis shim install
# DO NOT EDIT - regenerate with 'airis shim install'
set -euo pipefail

CMD="$(basename "$0")"
ARGS=("$@")

# Configuration from manifest.toml
COMPOSE="{compose}"
DEFAULT_SERVICE="{default_service}"
DEFAULT_WORKDIR="{default_workdir}"

# Find workspace root (where manifest.toml is)
find_root() {{
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/manifest.toml" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    echo "$PWD"
}}

ROOT="$(find_root)"
cd "$ROOT"

# Calculate relative path from root
REL_PATH="${{PWD#$ROOT}}"
REL_PATH="${{REL_PATH#/}}"
[[ -z "$REL_PATH" ]] && REL_PATH="."

# Extract first directory for matching
MATCH="${{REL_PATH%%/*}}"

# Route based on path
SERVICE="$DEFAULT_SERVICE"
WORKDIR="$DEFAULT_WORKDIR"

case "$REL_PATH" in{route_cases}
    *)
      # Default: use manifest defaults
      if [[ "$REL_PATH" != "." ]]; then
        WORKDIR="$DEFAULT_WORKDIR/$REL_PATH"
      fi
      ;;
esac

# Replace {{match}} placeholder if present
WORKDIR="${{WORKDIR//\{{match\}}/$MATCH}}"

# Check if service is running
if ! docker compose -f "$COMPOSE" ps --status running "$SERVICE" 2>/dev/null | grep -q "$SERVICE"; then
    # Service not running, use 'run' instead of 'exec'
    exec docker compose -f "$COMPOSE" run --rm -T -w "$WORKDIR" "$SERVICE" "$CMD" "${{ARGS[@]}}"
else
    # Service running, use 'exec'
    exec docker compose -f "$COMPOSE" exec -T -w "$WORKDIR" "$SERVICE" "$CMD" "${{ARGS[@]}}"
fi
"##,
        compose = compose,
        default_service = default_service,
        default_workdir = default_workdir,
        route_cases = route_cases,
    );

    fs::write(path, script)?;

    // Make executable
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms)?;

    Ok(())
}

/// Create a command wrapper that calls _shim
fn create_command_wrapper(path: &Path) -> Result<()> {
    let script = r#"#!/usr/bin/env bash
# Auto-generated by airis shim install
DIR="$(cd "$(dirname "$0")" && pwd)"
exec "$DIR/_shim" "$@"
"#;

    fs::write(path, script)?;

    // Make executable
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms)?;

    Ok(())
}

/// Execute a command through the shim (for direct 'airis exec' usage)
pub fn exec(cmd: &str, args: &[String]) -> Result<()> {
    let manifest = Manifest::load(MANIFEST_FILE)
        .context("Failed to load manifest.toml")?;

    let cwd = env::current_dir()?;
    let root = find_workspace_root(&cwd)?;
    let rel_path = cwd.strip_prefix(&root).unwrap_or(Path::new("."));

    // Find matching route
    let (service, workdir) = find_route(&manifest, rel_path);

    let compose = &manifest.docker.compose;

    // Build command
    let mut docker_args = vec![
        "compose".to_string(),
        "-f".to_string(),
        compose.clone(),
    ];

    // Check if service is running
    let status = Command::new("docker")
        .args(["compose", "-f", compose, "ps", "--status", "running", &service])
        .output()?;

    let is_running = String::from_utf8_lossy(&status.stdout).contains(&service);

    if is_running {
        docker_args.extend(["exec".to_string(), "-T".to_string()]);
    } else {
        docker_args.extend(["run".to_string(), "--rm".to_string(), "-T".to_string()]);
    }

    docker_args.extend([
        "-w".to_string(),
        workdir,
        service,
        cmd.to_string(),
    ]);
    docker_args.extend(args.iter().cloned());

    // Execute
    let status = Command::new("docker")
        .args(&docker_args)
        .stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()?;

    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }

    Ok(())
}

/// Find workspace root (directory containing manifest.toml)
///
/// STRICT MODE (default): Returns error if manifest.toml is not found.
/// This prevents LLM/user confusion from running in wrong directory.
///
/// ESCAPE HATCH: Set AIRIS_ALLOW_PWD_FALLBACK=1 to allow fallback to cwd.
fn find_workspace_root(start: &Path) -> Result<PathBuf> {
    let mut dir = start.to_path_buf();
    loop {
        if dir.join(MANIFEST_FILE).exists() {
            return Ok(dir);
        }
        if !dir.pop() {
            // Check for escape hatch
            if env::var("AIRIS_ALLOW_PWD_FALLBACK").is_ok() {
                return Ok(start.to_path_buf());
            }
            // Strict mode: fail with helpful error
            anyhow::bail!(
                "manifest.toml not found. Run from within an airis workspace.\n\n\
                 Hint: Run `airis manifest json` to verify workspace root.\n\
                 Override: Set AIRIS_ALLOW_PWD_FALLBACK=1 to allow fallback to current directory."
            );
        }
    }
}

/// Find the matching route for a path
fn find_route(manifest: &Manifest, rel_path: &Path) -> (String, String) {
    let rel_str = rel_path.to_string_lossy();

    for route in &manifest.docker.routes {
        if let Ok(pattern) = Pattern::new(&route.glob)
            && pattern.matches(&rel_str) {
                // Extract match for {match} placeholder
                let match_str = rel_path
                    .components()
                    .next()
                    .map(|c| c.as_os_str().to_string_lossy().to_string())
                    .unwrap_or_default();

                let workdir = route.workdir.replace("{match}", &match_str);
                return (route.service.clone(), workdir);
            }
    }

    // Default
    let workdir = if rel_str.is_empty() || rel_str == "." {
        manifest.docker.workdir.clone()
    } else {
        format!("{}/{}", manifest.docker.workdir, rel_str)
    };

    (manifest.docker.service.clone(), workdir)
}

/// List installed shims
pub fn list() -> Result<()> {
    let bin_dir = Path::new("bin");

    if !bin_dir.exists() {
        println!("{}", "No shims installed. Run 'airis shim install' first.".yellow());
        return Ok(());
    }

    println!("{}", "üìã Installed shims:".bright_blue());
    println!();

    for entry in fs::read_dir(bin_dir)? {
        let entry = entry?;
        let name = entry.file_name();
        let name_str = name.to_string_lossy();

        if name_str.starts_with('.') || name_str == "_shim" {
            continue;
        }

        println!("   bin/{}", name_str);
    }

    Ok(())
}

/// Marker content that identifies airis-generated shim files
const SHIM_MARKER: &str = "Auto-generated by airis shim install";

/// Check if a file is an airis-generated shim
fn is_airis_shim(path: &Path) -> bool {
    if let Ok(content) = fs::read_to_string(path) {
        content.contains(SHIM_MARKER)
    } else {
        false
    }
}

/// Remove only airis-generated shims (safe uninstall)
pub fn uninstall() -> Result<()> {
    let bin_dir = Path::new("bin");

    if !bin_dir.exists() {
        println!("{}", "No shims to remove.".yellow());
        return Ok(());
    }

    println!("{}", "üóëÔ∏è  Removing airis shims...".bright_blue());
    println!();

    let mut removed = 0;
    let mut skipped = 0;

    for entry in fs::read_dir(bin_dir)? {
        let entry = entry?;
        let path = entry.path();
        let name = entry.file_name();
        let name_str = name.to_string_lossy();

        // Skip hidden files
        if name_str.starts_with('.') {
            continue;
        }

        // Only remove files that are airis-generated shims
        if path.is_file() && is_airis_shim(&path) {
            fs::remove_file(&path)?;
            println!("   {} bin/{}", "‚úì".green(), name_str);
            removed += 1;
        } else if path.is_file() {
            println!("   {} bin/{} (not an airis shim, skipped)", "‚è≠Ô∏è".yellow(), name_str);
            skipped += 1;
        }
    }

    println!();

    if removed == 0 && skipped == 0 {
        println!("{}", "No airis shims found.".yellow());
    } else {
        println!(
            "{} Removed {} shim(s), skipped {} file(s)",
            "‚úÖ".green(),
            removed,
            skipped
        );
    }

    // Only remove bin directory if it's empty
    if bin_dir.exists() {
        let is_empty = fs::read_dir(bin_dir)?.next().is_none();
        if is_empty {
            fs::remove_dir(bin_dir)?;
            println!("{}", "   Removed empty bin/ directory".dimmed());
        } else {
            println!(
                "{}",
                "   bin/ directory retained (contains non-airis files)".dimmed()
            );
        }
    }

    Ok(())
}
