use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use colored::Colorize;

use crate::manifest::{Manifest, Mode, MANIFEST_FILE};

/// Additional commands blocked in strict mode
const STRICT_MODE_DENY: &[&str] = &[
    "cargo", "rustc", "python", "python3", "pip", "pip3", "uv",
    "go", "java", "javac", "gradle", "mvn",
];

/// Commands allowed in hybrid mode (local builds)
const HYBRID_MODE_ALLOW: &[&str] = &[
    "cargo", "rustc", "python", "python3", "pip", "pip3", "uv",
];

const GUARDS_DIR: &str = ".airis/bin";

/// Install command guards from manifest.toml
pub fn install() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        anyhow::bail!(
            "manifest.toml not found. Run `airis init` first."
        );
    }

    let manifest = Manifest::load(manifest_path)?;

    // Collect effective deny list based on mode
    let mut effective_deny: Vec<String> = manifest.guards.deny.clone();

    // Apply mode-specific guards
    match &manifest.mode {
        Mode::DockerFirst => {
            // Standard mode: use guards as configured
            println!("{}", "Mode: docker-first (standard guards)".dimmed());
        }
        Mode::Hybrid => {
            // Hybrid mode: allow local toolchains (cargo, python, etc.)
            println!("{}", "Mode: hybrid (allowing local toolchains)".yellow());
            effective_deny.retain(|cmd| !HYBRID_MODE_ALLOW.contains(&cmd.as_str()));
        }
        Mode::Strict => {
            // Strict mode: block additional commands
            println!("{}", "Mode: strict (maximum restrictions)".bright_red());
            for cmd in STRICT_MODE_DENY {
                if !effective_deny.contains(&cmd.to_string()) {
                    effective_deny.push(cmd.to_string());
                }
            }
        }
    }

    if effective_deny.is_empty()
        && manifest.guards.wrap.is_empty()
        && manifest.guards.deny_with_message.is_empty() {
        println!("{}", "âš ï¸  No guards to install (all commands allowed in this mode)".yellow());
        return Ok(());
    }

    println!("{}", "ğŸ›¡ï¸  Installing command guards...".bright_blue());
    println!();

    let guards_dir = PathBuf::from(GUARDS_DIR);
    fs::create_dir_all(&guards_dir)
        .with_context(|| format!("Failed to create {}", GUARDS_DIR))?;

    let mut installed_count = 0;

    // Install deny guards (mode-adjusted)
    for cmd in &effective_deny {
        install_deny_guard(&guards_dir, cmd, None)?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} (deny)", cmd).dimmed());
    }

    // Install wrap guards
    for (cmd, wrapper) in &manifest.guards.wrap {
        install_wrap_guard(&guards_dir, cmd, wrapper)?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} â†’ {}", cmd, wrapper).dimmed());
    }

    // Install deny with message guards
    for (cmd, message) in &manifest.guards.deny_with_message {
        install_deny_guard(&guards_dir, cmd, Some(message))?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} (deny with message)", cmd).dimmed());
    }

    println!();
    println!("{}", format!("âœ… {} command guards installed", installed_count).green());
    println!();
    println!("{}", "To activate guards:".bright_yellow());
    println!("  export PATH=\"$PWD/{}:$PATH\"", GUARDS_DIR);
    println!();
    println!("{}", "Or use airis shell:".bright_yellow());
    println!("  airis shell");

    Ok(())
}

fn install_deny_guard(guards_dir: &Path, cmd: &str, custom_message: Option<&String>) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let message = if let Some(msg) = custom_message {
        msg.clone()
    } else {
        format!("'{}' is denied by manifest.toml [guards.deny].\n\nUse Docker-first workflow instead:\n  airis shell     # Enter container\n  {}              # Run inside container", cmd, cmd)
    };

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards] section

echo "âŒ ERROR: {}"
exit 1
"#,
        message.replace("\"", "\\\"")
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn install_wrap_guard(guards_dir: &Path, cmd: &str, wrapper: &str) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards.wrap] section

# Wrapper: {} â†’ {}
exec {} "$@"
"#,
        cmd, wrapper, wrapper
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn make_executable(path: &Path) -> Result<()> {
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755); // rwxr-xr-x
    fs::set_permissions(path, perms)?;
    Ok(())
}

/// Check if running inside Docker container (respects mode)
pub fn check_docker() -> Result<()> {
    // Load manifest to check mode
    let manifest_path = Path::new(MANIFEST_FILE);
    let mode = if manifest_path.exists() {
        Manifest::load(manifest_path).map(|m| m.mode).unwrap_or_default()
    } else {
        Mode::default()
    };

    // Hybrid mode allows host execution
    if matches!(mode, Mode::Hybrid) {
        println!("{}", "âœ… Hybrid mode: host execution allowed".green());
        return Ok(());
    }

    println!("{}", "ğŸ” Checking Docker environment...".bright_blue());

    // Check DOCKER_CONTAINER environment variable
    if std::env::var("DOCKER_CONTAINER").unwrap_or_default() == "true" {
        println!("{}", "âœ… Running inside Docker container (DOCKER_CONTAINER=true)".green());
        return Ok(());
    }

    // Check for /.dockerenv file
    if Path::new("/.dockerenv").exists() {
        println!("{}", "âœ… Running inside Docker container (/.dockerenv exists)".green());
        return Ok(());
    }

    // Check /proc/1/cgroup for Docker
    if let Ok(content) = fs::read_to_string("/proc/1/cgroup")
        && (content.contains("docker") || content.contains("containerd")) {
            println!("{}", "âœ… Running inside Docker container (cgroup detected)".green());
            return Ok(());
        }

    // Check for CI environment
    if std::env::var("CI").unwrap_or_default() == "true"
        || std::env::var("GITHUB_ACTIONS").unwrap_or_default() == "true"
        || std::env::var("GITLAB_CI").unwrap_or_default() == "true"
    {
        println!("{}", "âœ… Running in CI environment".green());
        return Ok(());
    }

    // Not in Docker - show error
    println!();
    println!("{}", "=".repeat(70).red());
    println!("{}", "âŒ CRITICAL ERROR: Not running inside Docker container".red().bold());
    println!("{}", "=".repeat(70).red());
    println!();
    println!("{}", "ã€å•é¡Œã€‘".bright_yellow());
    println!("  Mac ãƒ›ã‚¹ãƒˆä¸Šã§å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚");
    println!("  Docker-Firsté–‹ç™ºã§ã¯ã€å…¨ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã¯Dockerå†…ã§å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚");
    println!();
    println!("{}", "ã€æ­£ã—ã„ä½¿ç”¨æ–¹æ³•ã€‘".bright_yellow());
    println!("  1. {} # Docker ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«å…¥ã‚‹", "airis shell".cyan());
    println!("  2. ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ");
    println!();
    println!("{}", "ã€ã¾ãŸã¯ã€‘".bright_yellow());
    println!("  {} # ã‚³ãƒ³ãƒ†ãƒŠå†…ã§ç›´æ¥å®Ÿè¡Œ", "airis exec workspace <command>".cyan());
    println!();
    println!("{}", "ã€ãƒ’ãƒ³ãƒˆã€‘".bright_yellow());
    println!("  ãƒ›ã‚¹ãƒˆã§ã®å®Ÿè¡Œã‚’è¨±å¯ã™ã‚‹ã«ã¯ã€manifest.toml ã§ mode = \"hybrid\" ã‚’è¨­å®šã—ã¦ãã ã•ã„");
    println!();
    println!("{}", "=".repeat(70).red());

    anyhow::bail!("Not running inside Docker container");
}

/// Show guard status
pub fn status() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        println!("{}", "âš ï¸  manifest.toml not found".yellow());
        return Ok(());
    }

    let manifest = Manifest::load(manifest_path)?;
    let guards_dir = PathBuf::from(GUARDS_DIR);

    println!("{}", "ğŸ›¡ï¸  Guard Status".bright_blue());
    println!();

    // Check if guards directory exists
    if !guards_dir.exists() {
        println!("{}", "Guards not installed. Run: airis guards install".yellow());
        return Ok(());
    }

    // Show deny guards
    if !manifest.guards.deny.is_empty() {
        println!("{}", "Deny guards:".bright_yellow());
        for cmd in &manifest.guards.deny {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {}", status, cmd);
        }
        println!();
    }

    // Show wrap guards
    if !manifest.guards.wrap.is_empty() {
        println!("{}", "Wrap guards:".bright_yellow());
        for (cmd, wrapper) in &manifest.guards.wrap {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {} â†’ {}", status, cmd, wrapper.dimmed());
        }
        println!();
    }

    // Show deny with message
    if !manifest.guards.deny_with_message.is_empty() {
        println!("{}", "Deny with message:".bright_yellow());
        for (cmd, _) in &manifest.guards.deny_with_message {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {}", status, cmd);
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strict_mode_deny_list() {
        // Strict mode should block cargo, python, etc.
        assert!(STRICT_MODE_DENY.contains(&"cargo"));
        assert!(STRICT_MODE_DENY.contains(&"python"));
        assert!(STRICT_MODE_DENY.contains(&"go"));
    }

    #[test]
    fn test_hybrid_mode_allow_list() {
        // Hybrid mode should allow cargo, python, etc.
        assert!(HYBRID_MODE_ALLOW.contains(&"cargo"));
        assert!(HYBRID_MODE_ALLOW.contains(&"python"));
    }

    #[test]
    fn test_hybrid_mode_filters_deny_list() {
        // Simulate hybrid mode filtering
        let deny_list = vec![
            "npm".to_string(),
            "yarn".to_string(),
            "cargo".to_string(),
            "python".to_string(),
        ];

        let filtered: Vec<String> = deny_list
            .into_iter()
            .filter(|cmd| !HYBRID_MODE_ALLOW.contains(&cmd.as_str()))
            .collect();

        // npm and yarn should remain denied
        assert!(filtered.contains(&"npm".to_string()));
        assert!(filtered.contains(&"yarn".to_string()));
        // cargo and python should be allowed
        assert!(!filtered.contains(&"cargo".to_string()));
        assert!(!filtered.contains(&"python".to_string()));
    }

    #[test]
    fn test_strict_mode_adds_to_deny_list() {
        // Simulate strict mode adding commands
        let mut deny_list: Vec<String> = vec!["npm".to_string(), "yarn".to_string()];

        for cmd in STRICT_MODE_DENY {
            if !deny_list.contains(&cmd.to_string()) {
                deny_list.push(cmd.to_string());
            }
        }

        // Should now contain both original and strict mode commands
        assert!(deny_list.contains(&"npm".to_string()));
        assert!(deny_list.contains(&"cargo".to_string()));
        assert!(deny_list.contains(&"python".to_string()));
    }
}
