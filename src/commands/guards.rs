use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use colored::Colorize;

use crate::manifest::{Manifest, MANIFEST_FILE};

const GUARDS_DIR: &str = ".airis/bin";

/// Install command guards from manifest.toml
pub fn install() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        anyhow::bail!(
            "manifest.toml not found. Run `airis init` first."
        );
    }

    let manifest = Manifest::load(manifest_path)?;

    if manifest.guards.deny.is_empty()
        && manifest.guards.wrap.is_empty()
        && manifest.guards.deny_with_message.is_empty() {
        println!("{}", "âš ï¸  No guards defined in manifest.toml [guards] section".yellow());
        println!("\nExample configuration:");
        println!("  [guards]");
        println!("  deny = [\"npm\", \"yarn\"]");
        println!("  wrap.pnpm = \"docker compose exec workspace pnpm\"");
        return Ok(());
    }

    println!("{}", "ğŸ›¡ï¸  Installing command guards...".bright_blue());
    println!();

    let guards_dir = PathBuf::from(GUARDS_DIR);
    fs::create_dir_all(&guards_dir)
        .with_context(|| format!("Failed to create {}", GUARDS_DIR))?;

    let mut installed_count = 0;

    // Install deny guards
    for cmd in &manifest.guards.deny {
        install_deny_guard(&guards_dir, cmd, None)?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} (deny)", cmd).dimmed());
    }

    // Install wrap guards
    for (cmd, wrapper) in &manifest.guards.wrap {
        install_wrap_guard(&guards_dir, cmd, wrapper)?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} â†’ {}", cmd, wrapper).dimmed());
    }

    // Install deny with message guards
    for (cmd, message) in &manifest.guards.deny_with_message {
        install_deny_guard(&guards_dir, cmd, Some(message))?;
        installed_count += 1;
        println!("   {} {}", "âœ“".green(), format!("{} (deny with message)", cmd).dimmed());
    }

    println!();
    println!("{}", format!("âœ… {} command guards installed", installed_count).green());
    println!();
    println!("{}", "To activate guards:".bright_yellow());
    println!("  export PATH=\"$PWD/{}:$PATH\"", GUARDS_DIR);
    println!();
    println!("{}", "Or use airis shell:".bright_yellow());
    println!("  airis shell");

    Ok(())
}

fn install_deny_guard(guards_dir: &Path, cmd: &str, custom_message: Option<&String>) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let message = if let Some(msg) = custom_message {
        msg.clone()
    } else {
        format!("'{}' is denied by manifest.toml [guards.deny].\n\nUse Docker-first workflow instead:\n  airis shell     # Enter container\n  {}              # Run inside container", cmd, cmd)
    };

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards] section

echo "âŒ ERROR: {}"
exit 1
"#,
        message.replace("\"", "\\\"")
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn install_wrap_guard(guards_dir: &Path, cmd: &str, wrapper: &str) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards.wrap] section

# Wrapper: {} â†’ {}
exec {} "$@"
"#,
        cmd, wrapper, wrapper
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn make_executable(path: &Path) -> Result<()> {
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755); // rwxr-xr-x
    fs::set_permissions(path, perms)?;
    Ok(())
}

/// Check if running inside Docker container
pub fn check_docker() -> Result<()> {
    println!("{}", "ğŸ” Checking Docker environment...".bright_blue());

    // Check DOCKER_CONTAINER environment variable
    if std::env::var("DOCKER_CONTAINER").unwrap_or_default() == "true" {
        println!("{}", "âœ… Running inside Docker container (DOCKER_CONTAINER=true)".green());
        return Ok(());
    }

    // Check for /.dockerenv file
    if Path::new("/.dockerenv").exists() {
        println!("{}", "âœ… Running inside Docker container (/.dockerenv exists)".green());
        return Ok(());
    }

    // Check /proc/1/cgroup for Docker
    if let Ok(content) = fs::read_to_string("/proc/1/cgroup") {
        if content.contains("docker") || content.contains("containerd") {
            println!("{}", "âœ… Running inside Docker container (cgroup detected)".green());
            return Ok(());
        }
    }

    // Check for CI environment
    if std::env::var("CI").unwrap_or_default() == "true"
        || std::env::var("GITHUB_ACTIONS").unwrap_or_default() == "true"
        || std::env::var("GITLAB_CI").unwrap_or_default() == "true"
    {
        println!("{}", "âœ… Running in CI environment".green());
        return Ok(());
    }

    // Not in Docker - show error
    println!();
    println!("{}", "=".repeat(70).red());
    println!("{}", "âŒ CRITICAL ERROR: Not running inside Docker container".red().bold());
    println!("{}", "=".repeat(70).red());
    println!();
    println!("{}", "ã€å•é¡Œã€‘".bright_yellow());
    println!("  Mac ãƒ›ã‚¹ãƒˆä¸Šã§å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚");
    println!("  Docker-Firsté–‹ç™ºã§ã¯ã€å…¨ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã¯Dockerå†…ã§å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚");
    println!();
    println!("{}", "ã€æ­£ã—ã„ä½¿ç”¨æ–¹æ³•ã€‘".bright_yellow());
    println!("  1. {} # Docker ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã«å…¥ã‚‹", "airis shell".cyan());
    println!("  2. ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ");
    println!();
    println!("{}", "ã€ã¾ãŸã¯ã€‘".bright_yellow());
    println!("  {} # ã‚³ãƒ³ãƒ†ãƒŠå†…ã§ç›´æ¥å®Ÿè¡Œ", "airis exec workspace <command>".cyan());
    println!();
    println!("{}", "=".repeat(70).red());

    anyhow::bail!("Not running inside Docker container");
}

/// Show guard status
pub fn status() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        println!("{}", "âš ï¸  manifest.toml not found".yellow());
        return Ok(());
    }

    let manifest = Manifest::load(manifest_path)?;
    let guards_dir = PathBuf::from(GUARDS_DIR);

    println!("{}", "ğŸ›¡ï¸  Guard Status".bright_blue());
    println!();

    // Check if guards directory exists
    if !guards_dir.exists() {
        println!("{}", "Guards not installed. Run: airis guards install".yellow());
        return Ok(());
    }

    // Show deny guards
    if !manifest.guards.deny.is_empty() {
        println!("{}", "Deny guards:".bright_yellow());
        for cmd in &manifest.guards.deny {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {}", status, cmd);
        }
        println!();
    }

    // Show wrap guards
    if !manifest.guards.wrap.is_empty() {
        println!("{}", "Wrap guards:".bright_yellow());
        for (cmd, wrapper) in &manifest.guards.wrap {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {} â†’ {}", status, cmd, wrapper.dimmed());
        }
        println!();
    }

    // Show deny with message
    if !manifest.guards.deny_with_message.is_empty() {
        println!("{}", "Deny with message:".bright_yellow());
        for (cmd, _) in &manifest.guards.deny_with_message {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "âœ“".green() } else { "âœ—".red() };
            println!("  {} {}", status, cmd);
        }
    }

    Ok(())
}
