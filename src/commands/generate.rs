use anyhow::{Context, Result};
use colored::Colorize;
use indexmap::IndexMap;
use std::env;
use std::fs;
use std::path::Path;

use crate::commands::sync_deps::resolve_version;
use crate::generators::package_json::generate_project_package_json;
use crate::manifest::{CatalogEntry, Manifest};
use crate::templates::TemplateEngine;

/// Check if a file is safe to overwrite (either doesn't exist or is auto-generated)
/// Returns true if safe to write, false if manual file should be preserved
fn is_safe_to_overwrite(path: &Path) -> bool {
    if !path.exists() {
        return true;
    }

    let content = fs::read_to_string(path).unwrap_or_default();

    // Check for auto-generation markers
    content.contains("Auto-generated by airis")
        || content.contains("DO NOT EDIT")
        || content.contains("\"_generated\"")
}

/// Backup a manual file before overwriting
/// Creates a .md backup (e.g., package.json â†’ package.json.md)
fn backup_if_manual(path: &Path) -> Result<bool> {
    if !path.exists() {
        return Ok(false);
    }

    if is_safe_to_overwrite(path) {
        return Ok(false);
    }

    // Create backup with .md extension
    let filename = path.file_name().unwrap_or_default().to_str().unwrap_or("");
    let backup_name = format!("{}.md", filename);
    let backup_path = path.with_file_name(backup_name);

    fs::copy(path, &backup_path)
        .with_context(|| format!("Failed to backup {} to {}", path.display(), backup_path.display()))?;

    println!(
        "{} {} â†’ {}",
        "ðŸ“¦ Backed up".yellow(),
        path.display(),
        backup_path.display()
    );

    Ok(true)
}

/// Sync justfile/docker-compose/package.json from manifest.toml contents
pub fn sync_from_manifest(manifest: &Manifest) -> Result<()> {
    // Resolve catalog versions from npm registry
    let resolved_catalog = resolve_catalog_versions(&manifest.packages.catalog)?;

    let engine = TemplateEngine::new()?;
    println!("{}", "ðŸ§© Rendering templates...".bright_blue());
    generate_docker_compose(&manifest, &engine)?;
    generate_package_json(&manifest, &engine)?;
    generate_pnpm_workspace(&manifest, &engine, &resolved_catalog)?;

    // Check if this is a Rust project (for CI workflow detection)
    let is_rust_project = !manifest.project.rust_edition.is_empty()
        || !manifest.project.binary_name.is_empty();

    // Note: Cargo.toml is NOT generated - it's the source of truth for Rust projects
    // Use `airis bump-version` to sync versions between manifest.toml and Cargo.toml

    // Generate GitHub Actions workflows if CI is enabled
    if manifest.ci.enabled {
        generate_github_workflows(&manifest, &engine)?;
    }

    // Generate individual app package.json files
    if !manifest.app.is_empty() {
        println!();
        println!("{}", "ðŸ“¦ Generating app package.json files...".bright_blue());
        let workspace_root = env::current_dir().context("Failed to get current directory")?;

        for app in &manifest.app {
            generate_project_package_json(app, &workspace_root, &resolved_catalog)?;
        }
    }

    println!();
    println!("{}", "âœ… Generated files:".green());
    println!("   - package.json");
    println!("   - pnpm-workspace.yaml");
    if manifest.ci.enabled {
        println!("   - .github/workflows/ci.yml");
        println!("   - .github/workflows/release.yml");
    }
    if is_rust_project {
        println!();
        println!("{}", "â„¹ï¸  Cargo.toml is not generated (it's the source of truth)".cyan());
        println!("   Use `airis bump-version` to sync versions");
    }
    if !manifest.app.is_empty() {
        println!("   - {} app package.json files", manifest.app.len());
    }
    println!();
    println!("{}", "Next steps:".bright_yellow());
    println!("  1. Configure workspace/docker-compose.yml");
    println!("  2. Run `airis up`");

    Ok(())
}

fn generate_package_json(manifest: &Manifest, engine: &TemplateEngine) -> Result<()> {
    let path = Path::new("package.json");
    backup_if_manual(path)?;
    let content = engine.render_package_json(manifest)?;
    fs::write(path, content).context("Failed to write package.json")?;
    Ok(())
}

fn generate_pnpm_workspace(
    manifest: &Manifest,
    engine: &TemplateEngine,
    resolved_catalog: &IndexMap<String, String>,
) -> Result<()> {
    let path = Path::new("pnpm-workspace.yaml");
    backup_if_manual(path)?;
    let content = engine.render_pnpm_workspace(manifest, resolved_catalog)?;
    fs::write(path, content).context("Failed to write pnpm-workspace.yaml")?;
    Ok(())
}

/// Resolve catalog version policies to actual version numbers
fn resolve_catalog_versions(
    catalog: &IndexMap<String, CatalogEntry>,
) -> Result<IndexMap<String, String>> {
    if catalog.is_empty() {
        return Ok(IndexMap::new());
    }

    println!("{}", "ðŸ“¦ Resolving catalog versions from npm registry...".bright_blue());

    let mut resolved: IndexMap<String, String> = IndexMap::new();

    for (package, entry) in catalog {
        let version = match entry {
            CatalogEntry::Policy(policy) => {
                let policy_str = policy.as_str();
                let version = resolve_version(package, policy_str)?;
                println!("  âœ“ {} {} â†’ {}", package, policy_str, version);
                version
            }
            CatalogEntry::Version(version) => {
                println!("  âœ“ {} {}", package, version);
                version.clone()
            }
            CatalogEntry::Follow(follow_config) => {
                // For follow entries, we'll resolve them in a second pass
                let target = &follow_config.follow;
                if let Some(target_version) = resolved.get(target) {
                    println!("  âœ“ {} (follow {}) â†’ {}", package, target, target_version);
                    target_version.clone()
                } else {
                    anyhow::bail!(
                        "Cannot resolve '{}': follow target '{}' not found or not yet resolved",
                        package,
                        target
                    );
                }
            }
        };

        resolved.insert(package.clone(), version);
    }

    Ok(resolved)
}

fn generate_docker_compose(_manifest: &Manifest, _engine: &TemplateEngine) -> Result<()> {
    // Docker-compose generation is disabled.
    // The workspace/ directory should contain hand-crafted docker-compose.yml
    // that is optimized for the monorepo workflow.
    //
    // To use airis up, configure orchestration.dev in manifest.toml:
    //   [orchestration.dev]
    //   workspace = "workspace/docker-compose.yml"
    Ok(())
}

// Note: generate_cargo_toml has been removed
// Cargo.toml is the source of truth for Rust projects and should not be auto-generated
// Use `airis bump-version` to sync versions between manifest.toml and Cargo.toml

fn generate_github_workflows(manifest: &Manifest, engine: &TemplateEngine) -> Result<()> {
    // Create .github/workflows directory
    let workflows_dir = Path::new(".github/workflows");
    fs::create_dir_all(workflows_dir).context("Failed to create .github/workflows directory")?;

    // Generate ci.yml
    let ci_path = workflows_dir.join("ci.yml");
    backup_if_manual(&ci_path)?;
    let ci_content = engine.render_ci_yml(manifest)?;
    fs::write(&ci_path, ci_content).context("Failed to write ci.yml")?;

    // Generate release.yml
    let release_path = workflows_dir.join("release.yml");
    backup_if_manual(&release_path)?;
    let release_content = engine.render_release_yml(manifest)?;
    fs::write(&release_path, release_content).context("Failed to write release.yml")?;

    Ok(())
}
